# CS 320 Portfolio Submission

## Overview

This repository contains my portfolio artifacts from CS 320, showcasing my work in software testing, automation, and quality assurance. The artifacts demonstrate my ability to create unit tests to uncover errors, analyze various approaches to software testing based on requirements, and apply appropriate testing strategies to meet those requirements.

## Included Artifacts

- **Project One: Contact Service Files**
  - Contact.java
  - ContactService.java
  - ContactTest.java
  - ContactServiceTest.java
- **Project Two: Summary and Reflections Report**
  - Summary and Reflections Report included below

## Summary and Reflections Report

For Project One, I developed a mobile application with Contact, Task, and Appointment services, focusing on backend functionality without a user interface, and verified it using JUnit tests in VSCode with Maven, achieving 100% test coverage. My unit testing approach covered all requirements, including unique IDs, field limits, null checks, and proper updating or deletion operations, ensuring that any change in the code would be caught by failing tests. The tests were effective and efficient, using loops and modular code to avoid redundancy while keeping everything organized, and running them in Maven confirmed that all cases passed. I made sure the code was technically sound by checking object instantiations, exception handling, and boundary conditions, and I wrote tests that reflected realistic usage and edge cases. I primarily used unit testing and boundary testing, which allowed me to verify individual classes and catch issues early, while I did not employ integration or stress testing, which would have been more relevant for larger, interacting systems. Throughout the project, I worked with caution and discipline, double-checking tests, thinking about potential side effects, and minimizing bias by approaching my code as if it was written by someone else, which helped prevent technical debt and ensured high-quality code. Finally, I translated user requirements into testable scenarios, designed modular and reusable classes, and focused on maintaining a professional mindset that balances caution, efficiency, and thoroughness, which prepares me for more complex software development projects in the future.

## Reflections on Portfolio Work

This portfolio demonstrates my ability to interpret requirements, design software, write technically sound and efficient code, and apply robust software testing techniques. Submitting these artifacts highlights my growth in applying unit tests, understanding code interdependencies, and documenting my work in a professional manner for future employers or coursework, for this portfolio submission, I included some of my best work from this course. From Project One, I added the contact service files (Contact.java, ContactService.java, ContactTest.java, ContactServiceTest.java), which showcase my ability to write unit tests, uncover errors, and ensure software functionality. From Project Two, I included my summary and reflections report, which highlights how I analyzed testing approaches based on requirements and applied strategies to make sure the code works correctly. Together, these artifacts demonstrate my skills in software testing, automation, and quality assurance.

## How to ensure Functional and Secure Code?

 To make sure my code and programs are functional and secure, I focus on thorough unit testing and coverage, double-checking input validation, and following best practices for secure coding. Using Maven and JUnit in VSCode helped me automate tests and ensure everything runs as expected. I also pay attention to potential edge cases and scenarios that might break the software, which helps reduce bugs before deployment.

## How to interpret User Needs?

 Understanding what the user actually needs is key, so I make sure to carefully review requirements before writing any code. I break down the features into smaller tasks and check that each one aligns with what the user wants. Feedback from milestones also helped me adjust my approach to make the code more accurate and user-focused.

## How to approach Designing Software?

 I usually start with planning and mapping out the components of the program, thinking about how classes and services interact, and identifying where tests are needed. Then I code in small, testable parts and continuously test them as I go. This approach keeps the design modular, easier to maintain, and reduces the chance of introducing bugs.
Overall, this portfolio submission shows not just the work Iâ€™ve done, but the thought process behind it, the testing strategies I used, and my focus on delivering high-quality, reliable software.

